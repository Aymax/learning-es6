{"version":3,"sources":["../es6/block-scoping.js"],"names":[],"mappings":";;AAAA,SAAS,UAAU,GAAG;AACrB,KAAI,KAAK,GAAG,CAAC,CAAC;;AAEd,QAAO,CAAC,GAAG,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;;;;;;AAM9C,QAAO,CAAC,GAAG,CAAC,6BAA6B,EAAE,QAAQ,CAAC,CAAC;;AAErD,SAAQ,GAAG,EAAE,CAAC;;;AAGd,KAAI,KAAK,GAAG,EAAE,EAAE;;AAEf,MAAI,KAAK,GAAG,KAAK,CAAC;AAClB,MAAI,QAAQ,GAAG,IAAI,CAAC;;AAEpB,SAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC;EACzC;;;;AAID,KAAI,QAAQ,CAAC;;;;AAIb,QAAO,CAAC,GAAG,CAAC,4BAA4B,EAAE,QAAQ,CAAC,CAAC;;;;;AAKpD,QAAO,CAAC,GAAG,CAAC,qBAAqB,EAAE,KAAK,KAAK,CAAC,CAAC,CAAC;;;;;AAKhD,QAAO,CAAC,GAAG,CAAC,wBAAwB,EAAE,QAAQ,CAAC,CAAC;CAChD;;AAED,SAAS,UAAU,CAAC,KAAK,EAAE;AAC1B,KAAI,KAAK,EAAE;AACV,MAAI,SAAQ,GAAG,KAAK,CAAC;;AAErB,SAAO,CAAC,GAAG,CAAC,cAAc,EAAE,SAAQ,CAAC,CAAC;;;;EAItC;;AAED,KAAI;;;AAGH,SAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;;;;;;AAMtB,SAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;EAC1C,CACD,OAAO,CAAC,EAAE;;AAET,SAAO,CAAC,GAAG,CAAC,yBAAyB,EAAE,CAAC,CAAC,CAAC;EAC1C;CACD;;AAED,UAAU,EAAE,CAAC;AACb,UAAU,CAAC,CAAC,CAAC,CAAC","file":"block-scoping-babel.js","sourcesContent":["function varExample() {\n\tvar myVar = 7;\n\n\tconsole.log('myVar after declaration', myVar);\n\n\t// even though laterVar is defined later on in the function\n\t// it is \"hoisted\" to the beginning of the function &\n\t// initialized to undefined. In most C-style languages this would\n\t// be an error.\n\tconsole.log('laterVar before declaration', laterVar);\n\n\tlaterVar = 10;\n\n\t// image some legitimate conditional\n\tif (myVar < 20) {\n\t\t// accidental redefintion of myVar\n\t\tvar myVar = 'foo';\n\t\tvar innerVar = true;\n\n\t\tconsole.log('myVar inside block', myVar);\n\t}\n\n\t// since this declaration was \"hoisted\", it's as if it's no\n\t// longer here but at the top of the function\n\tvar laterVar;\n\n\t// looking at the code laterVar *should* be undefined,\n\t// but it has the value 10 from earlier\n\tconsole.log('laterVar after declaration', laterVar);\n\n\t// we would expect myVar to still be 7\n\t// but it was redefined and overwritten\n\t// w/in the conditional\n\tconsole.log('myVar outside block', myVar === 7);\n\n\t// we would expect innerVar to no longer be accessible\n\t// since it was defined w/in the if-block, but it was\n\t// \"hoisted\" as well\n\tconsole.log('innerVar outside block', innerVar);\n}\n\nfunction letExample(value) {\n\tif (value) {\n\t\tlet letValue = value;\n\n\t\tconsole.log('inside block', letValue);\n\n\t\t// redeclaration of letValue would be a TypeError\n\t\t//let letValue = 'foo';\n\t}\n\n\ttry {\n\t\t// Accessing letValue is a ReferenceError because it\n\t\t// was defined w/in if-block\n\t\tconsole.log(letValue);\n\n\t\t// if we get here, it means that the JS engine didn't\n\t\t// throw an exception, which means that the engine\n\t\t// (or transpiled code) did not faithfully reproduce\n\t\t// how let should work\n\t\tconsole.log('let not faithfully handled');\n\t}\n\tcatch (e) {\n\t\t// e is a ReferenceError\n\t\tconsole.log('letValue not accessible', e);\n\t}\n}\n\nvarExample();\nletExample(2);"]}